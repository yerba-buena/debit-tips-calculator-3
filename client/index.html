<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tip Allocation Client</title>
  <!-- Include PapaParse from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>
<body>
  <h1>Tip Allocation Pipeline</h1>
  <p>Select your CSV files and set your time interval (between 2 and 60 minutes, must evenly divide 1440):</p>
  
  <label for="clockFile">Clock Times CSV:</label>
  <input type="file" id="clockFile" accept=".csv"><br><br>
  
  <label for="transFile">Transactions CSV:</label>
  <input type="file" id="transFile" accept=".csv"><br><br>
  
  <label for="intervalInput">Interval (minutes):</label>
  <input type="number" id="intervalInput" value="15" min="2" max="60"><br><br>
  
  <button id="processButton">Process Data</button>
  
  <h2>Final Aggregated Tip Totals</h2>
  <div id="output"></div>
  
  <script>
  // --- Utility Functions ---
  function parseDateTime(dateStr, timeStr) {
    return new Date(dateStr + " " + timeStr);
  }
  
  function addMinutes(date, minutes) {
    return new Date(date.getTime() + minutes * 60000);
  }
  
  // Floor a date to the nearest interval (default 15 minutes)
  function floorToInterval(date, intervalMinutes = 15) {
    let minutes = date.getMinutes();
    let flooredMinutes = minutes - (minutes % intervalMinutes);
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), flooredMinutes, 0, 0);
  }
  
  // --- Clock Data Processing ---
  // Preprocess raw clock CSV: skip first 2 lines and remove last line (totals)
  function preprocessClockCSV(content) {
    const lines = content.split(/\r?\n/);
    const cleanedLines = lines.slice(2, lines.length - 1);
    return cleanedLines.join("\n");
  }
  
  // Process raw clock data rows into a structured format
  function processClockData(clockData) {
    return clockData.map(row => {
      const employee = row["First Name"] + " " + row["Last Name"];
      const timeIn = parseDateTime(row["Date In"], row["Time In"]);
      let timeOut = row["Time Out"] ? parseDateTime(row["Date Out"], row["Time Out"]) : null;
      if (!timeOut && row["Total Less Break"]) {
        const hours = parseFloat(row["Total Less Break"]);
        timeOut = addMinutes(timeIn, hours * 60);
      }
      const dateStr = timeIn.toISOString().split("T")[0];
      return {
        Employee: employee,
        Department: row["Department"],
        Date: dateStr,
        TimeIn: timeIn,
        TimeOut: timeOut
      };
    });
  }
  
  // Expand shifts into intervals based on the configurable time chunk.
  // If an employee clocks out mid-interval, they are credited for the full interval.
  function expandToIntervals(cleanedClock, intervalMinutes = 15) {
    // Validate the interval
    if (
      typeof intervalMinutes !== "number" ||
      intervalMinutes < 2 ||
      intervalMinutes > 60 ||
      1440 % intervalMinutes !== 0
    ) {
      console.warn("Invalid interval (" + intervalMinutes + "). Falling back to 15 minutes.");
      intervalMinutes = 15;
    }
  
    let intervals = [];
    cleanedClock.forEach(row => {
      let slotStart = new Date(row.TimeIn);
      while (slotStart < row.TimeOut) {
        let slotEnd = addMinutes(slotStart, intervalMinutes);
        intervals.push({
          Employee: row.Employee,
          Department: row.Department,
          Date: row.Date,
          TimeSlotStart: new Date(slotStart),
          TimeSlotEnd: new Date(slotEnd)
        });
        slotStart = slotEnd;
      }
    });
    return intervals;
  }
  
  // --- Transactions Processing ---
  function processTransactions(transactions) {
    let approved = transactions.filter(r => r.Approved && r.Approved.toLowerCase() === "yes")
      .map(r => {
        const transDT = new Date(r.TransDateTime);
        const floored = floorToInterval(transDT, 15); // Using 15-minute floor; you could adapt this as needed.
        const dateStr = floored.toISOString().split("T")[0];
        return {
          TransDateTime: transDT,
          AmtTip: parseFloat(r.AmtTip),
          TimeSlotStart: floored,
          Date: dateStr
        };
      });
  
    // Group by Date + TimeSlotStart
    let map = {};
    approved.forEach(txn => {
      const key = txn.Date + "|" + txn.TimeSlotStart.toISOString();
      if (!map[key]) {
        map[key] = { Date: txn.Date, TimeSlotStart: txn.TimeSlotStart, AmtTip: 0 };
      }
      map[key].AmtTip += txn.AmtTip;
    });
    return Object.values(map);
  }
  
  // --- Tip Allocation Logic ---
  function countStaffPerSlot(intervals) {
    let map = {};
    intervals.forEach(rec => {
      const key = rec.Date + "|" + rec.TimeSlotStart.toISOString();
      if (!map[key]) map[key] = { FOH: 0, BOH: 0 };
      if (rec.Department.toLowerCase().includes("front")) {
        map[key].FOH += 1;
      } else if (rec.Department.toLowerCase().includes("back")) {
        map[key].BOH += 1;
      }
    });
    return map;
  }
  
  function computeTipPools(tipsBySlot, staffMap) {
    return tipsBySlot.map(slot => {
      const key = slot.Date + "|" + slot.TimeSlotStart.toISOString();
      const staff = staffMap[key] || { FOH: 0, BOH: 0 };
      return {
        Date: slot.Date,
        TimeSlotStart: slot.TimeSlotStart,
        AmtTip: slot.AmtTip,
        FOHCount: staff.FOH,
        BOHCount: staff.BOH,
        FOHTipPool: slot.AmtTip * 0.85,
        BOHTipPool: slot.AmtTip * 0.15,
        TotalStaff: staff.FOH + staff.BOH
      };
    });
  }
  
  function calculateIndividualTipShares(intervals, tipPools) {
    let poolMap = {};
    tipPools.forEach(pool => {
      const key = pool.Date + "|" + pool.TimeSlotStart.toISOString();
      poolMap[key] = pool;
    });
    let shares = [];
    intervals.forEach(rec => {
      const key = rec.Date + "|" + rec.TimeSlotStart.toISOString();
      const pool = poolMap[key];
      let share = 0;
      if (pool) {
        if (rec.Department.toLowerCase().includes("front") && pool.FOHCount > 0) {
          share = pool.FOHTipPool / pool.FOHCount;
        } else if (rec.Department.toLowerCase().includes("back") && pool.BOHCount > 0) {
          share = pool.BOHTipPool / pool.BOHCount;
        }
      }
      shares.push({
        Employee: rec.Employee,
        Department: rec.Department,
        Date: rec.Date,
        TimeSlotStart: rec.TimeSlotStart,
        TimeSlotEnd: rec.TimeSlotEnd,
        IndividualTipShare: share
      });
    });
    return shares;
  }
  
  function identifyUnallocatedTips(tipPools) {
    let unallocated = [];
    tipPools.forEach(r => {
      if (r.TotalStaff === 0) {
        unallocated.push({ Date: r.Date, TimeSlotStart: r.TimeSlotStart, UnallocatedTip: r.AmtTip });
      } else if (r.AmtTip > 0 && (r.FOHCount === 0 || r.BOHCount === 0)) {
        let orphaned = 0;
        if (r.FOHCount === 0) orphaned += r.FOHTipPool;
        if (r.BOHCount === 0) orphaned += r.BOHTipPool;
        unallocated.push({ Date: r.Date, TimeSlotStart: r.TimeSlotStart, UnallocatedTip: orphaned });
      }
    });
    return unallocated;
  }
  
  function redistributeUnallocatedTips(unallocatedTips, intervals) {
    let unallocByDay = {};
    unallocatedTips.forEach(rec => {
      if (!unallocByDay[rec.Date]) unallocByDay[rec.Date] = 0;
      unallocByDay[rec.Date] += rec.UnallocatedTip;
    });
    let employeesByDay = {};
    intervals.forEach(rec => {
      if (!employeesByDay[rec.Date]) employeesByDay[rec.Date] = new Set();
      employeesByDay[rec.Date].add(rec.Employee);
    });
    let redistribution = [];
    for (let date in unallocByDay) {
      const totalUnalloc = unallocByDay[date];
      const employees = Array.from(employeesByDay[date] || []);
      const share = employees.length > 0 ? totalUnalloc / employees.length : 0;
      employees.forEach(emp => {
        redistribution.push({ Date: date, Employee: emp, UnallocatedTipShare: share });
      });
    }
    return redistribution;
  }
  
  function aggregateFinalTips(individualTipShares, redistribution) {
    let tipByEmployee = {};
    individualTipShares.forEach(rec => {
      if (!tipByEmployee[rec.Employee]) tipByEmployee[rec.Employee] = 0;
      tipByEmployee[rec.Employee] += rec.IndividualTipShare;
    });
    redistribution.forEach(rec => {
      if (!tipByEmployee[rec.Employee]) tipByEmployee[rec.Employee] = 0;
      tipByEmployee[rec.Employee] += rec.UnallocatedTipShare;
    });
    let finalTotals = [];
    for (let emp in tipByEmployee) {
      finalTotals.push({ Employee: emp, TotalTips: tipByEmployee[emp] });
    }
    return finalTotals;
  }
  
  // --- File Reading Helper ---
  function readFileContent(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = event => resolve(event.target.result);
      reader.onerror = error => reject(error);
      reader.readAsText(file);
    });
  }
  
  // --- Processing Pipeline Trigger ---
  document.getElementById("processButton").addEventListener("click", async () => {
    const clockFile = document.getElementById("clockFile").files[0];
    const transFile = document.getElementById("transFile").files[0];
    const intervalSize = parseInt(document.getElementById("intervalInput").value, 10);
  
    if (!clockFile || !transFile) {
      alert("Please select both CSV files.");
      return;
    }
  
    try {
      // Read and preprocess clock data
      let clockContent = await readFileContent(clockFile);
      clockContent = preprocessClockCSV(clockContent);
      const clockData = Papa.parse(clockContent, { header: true }).data;
  
      const cleanedClock = processClockData(clockData);
      const intervals = expandToIntervals(cleanedClock, intervalSize);
  
      // Read transactions file
      const transContent = await readFileContent(transFile);
      const transactionsData = Papa.parse(transContent, { header: true }).data;
      const tipsBySlot = processTransactions(transactionsData);
  
      // Run tip allocation pipeline
      const staffMap = countStaffPerSlot(intervals);
      const tipPools = computeTipPools(tipsBySlot, staffMap);
      const individualTipShares = calculateIndividualTipShares(intervals, tipPools);
      const unallocatedTips = identifyUnallocatedTips(tipPools);
      const redistribution = redistributeUnallocatedTips(unallocatedTips, intervals);
      const finalTotals = aggregateFinalTips(individualTipShares, redistribution);
  
      // Display results
      let outputHTML = "<table border='1'><tr><th>Employee</th><th>Total Tips</th></tr>";
      finalTotals.forEach(row => {
        outputHTML += `<tr><td>${row.Employee}</td><td>$${row.TotalTips.toFixed(2)}</td></tr>`;
      });
      outputHTML += "</table>";
      document.getElementById("output").innerHTML = outputHTML;
    } catch (err) {
      console.error(err);
      alert("An error occurred while processing the files.");
    }
  });
  </script>
</body>
</html>